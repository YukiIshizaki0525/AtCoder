s
v l
s
<<<<<<< HEAD
h[i+1]
h[i]
s
v l
i
v l
s
v l
s
h[i+1]
h[i]
=======
>>>>>>> master
v l
s
v l
s
<<<<<<< HEAD
exit
h[num].to_i
current
v l
s
h[num].to_i
current
v l
s
v l
s
h[num].to_i
current
s
v l
s
h[num].to_i
current
s
v l
s
v l
s
v l
s
h[num].to_i
v l
s
h[num].to_i
h
v l
=======
v l
s
v l
s
ss
aa
a
ans.product(a)
>>>>>>> master
s
v l
s
exit
v l
s
v l
s
v l
s
v l
s
x
v l
s
v l
s
exit
s
v l
s
exit
x.length
(x[x.length/2-1]+x[x.length/2])/2 
exit
5/2
x[x.length/2]
x[x.length/2-1]
exit
s
v l
s
v l
s
i*i
v l
s
v l
s
v l
s
exit
v l
s
v l
s
v l
s
v l
s
v l
s
v l
s
v l
s
v l
dp
v l
s
v l
s
v l
s
v l
s
exit
v l
exit
v l
s
v l
s
b
a
a,b
sa,b
tmp.uniq.dup
v l
s
exit
v l
s
v l
s
v l
s
exit
(a & b)
v l
s
v l
s
v l
s
exit
v l
s
exit
v l
s
max_y+1
v l
s
exit
v l
s
exit
Math.sqrt(5)**2.ceil
Math.sqrt(5)**2.floor
Math.sqrt(5)**2.round
Math.sqrt(5).round
Math.sqrt(5)**2.to_i
Math.sqrt(5)**2
Math.sqrt(5)
(x1-a)**2 + (y1-b)**2
(x1-a).abs)**2 + ((y1-b).abs)**2
v l
s
v l
v ;
s
v l
s
Math.sqrt(5)**2
((x1-a).abs)**2 + ((y1-b).abs)**2 
v l
s
v l
s
exit
v l
s
v l
s
v l
s
v l
s
v l
s
v l
s
v l
v lk
v l
s
v l
s
exit
v l
s
exit
v l
s
v l
s
v l
s
v l
s
v l
exit
v l
s
v l
s
v l
s
v l
s
s.length / 2
v l
s
exit
h[s[0]]
h.values.to_a
h.values.to_s
h.values.to_i
h.values
s.length
v l
s
exit
5 + (2 - 2).abs + (1 - 2).abs
5 + (2 - 2).abs + (3 - 2).abs
v l
v ;
s
v l
s
v l
s
sss
5 + (2 - cx).abs + (1 - cy).abs
5 + (2 - cx).abs + (3 - cy).abs
_3 + (_1 - cx).abs + (_2 - cy).abs
xyh.map{ _3 + (_1 - cx).abs + (_2 - cy).abs }
_3
v l
v l]
s
exit
v l
s
v l
s
ch
ch - (x - cx).abs - (y - cy).abs
v l
s
v l
s
v l
s
v l
s
v l
s
v l
s
v l
s
v l
s
exit
exity
[a,b].min
v l
s
v l
s
<<<<<<< HEAD
=======
<<<<<<< HEAD
P[2]
v l
s
P[1]
min
s
P[1]
p[1]
<<<<<<< HEAD
s
=======
v l
s
>>>>>>> master
v l
s
v l
s
v l
s
<<<<<<< HEAD
=======
v l
>>>>>>> master
exit
ary[i][j]%7
ary[i][j]%7=
>>>>>>> master
=======
>>>>>>> master
